# -*- coding: utf-8 -*-
"""handwriting_recognition.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QE06D9GF7pG0-In32HPDyWUUkZjmMQI2
"""

import numpy
import cv2 as cv
from keras.layers import Input, Conv2D, Activation, MaxPooling2D, Dense, Flatten
from keras.initializers import glorot_uniform
from keras.models import Model
from keras.regularizers import l2
from keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split
import csv

def convert_to_one_hot(v, c):
    v = numpy.eye(c)[v.reshape(-1)]
    return v

X = []
Y = []
with open('/content/drive/MyDrive/A_Z_Handwritten_Data.csv', 'r') as f:
    reader = csv.reader(f)
    for row in reader:
        if len(row) != 0:
            label = int(row[0])
            image = numpy.array([int(a) for a in row[1:]], dtype="uint8")
            image = image.reshape((28, 28))
            image = cv.resize(image, (32, 128))
            X.append(image)
            Y.append(label)

print("length of X: ", len(X))
print("length of Y: ", len(Y))
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2)
print("length of X_train: ", len(X_train))
print("length of Y_train: ", len(Y_train))
print("length of X_test: ", len(X_test))
print("length of Y_test: ", len(Y_test))

x_train_digits = []
y_train_digits = []
with open('/content/drive/MyDrive/digits_dataset_train.csv', 'r') as f:
    reader = csv.reader(f)
    header = next(reader)
    for row in reader:
        if len(row) != 0:
          label = int(row[0])
          image = numpy.array([int(a) for a in row[1:]], dtype="uint8")
          image = image.reshape((32, 32))
          image = cv.resize(image, (32, 128))
          x_train_digits.append(image)
          y_train_digits.append(label)

print('length of x_train_digits: ', len(x_train_digits))
print('length of y_train_digits: ', len(y_train_digits))
x_train_digits, _, y_train_digits, _ = train_test_split(x_train_digits, y_train_digits, train_size=34998)
print('length of x_train_digits: ', len(x_train_digits))
print('length of y_train_digits: ', len(y_train_digits))
for a in x_train_digits:
    X_train.append(a)
for b in y_train_digits:
    Y_train.append(b)
print("length of X_train: ", len(X_train))
print("length of Y_train: ", len(Y_train))

x_test_digits = []
y_test_digits = []
with open('/content/drive/MyDrive/digits_dataset_test.csv', 'r') as f:
    reader = csv.reader(f)
    header = next(reader)
    for row in reader:
        if len(row) != 0:
            label = int(row[0])
            image = numpy.array([int(a) for a in row[1:]], dtype="uint8")
            image = image.reshape((32, 32))
            image = cv.resize(image, (32, 128))
            x_test_digits.append(image)
            y_test_digits.append(label)

print('length of x_test_digits: ', len(x_test_digits))
print('length of y_test_digits: ', len(y_test_digits))
x_test_digits, _, y_test_digits, _ = train_test_split(x_test_digits, y_test_digits, train_size=8724)
print('length of x_test_digits: ', len(x_test_digits))
print('length of y_test_digits: ', len(y_test_digits))

for k in x_test_digits:
    X_test.append(k)
for m in y_test_digits:
    Y_test.append(m)
print("length of X_test: ", len(X_test))
print("length of Y_test: ", len(Y_test))

print('length of X_train: ', len(X_train))
print('length of Y_train: ', len(Y_train))
print('length of X_test: ', len(X_test))
print('length of Y_test: ', len(Y_test))

X_train = numpy.array(X_train)
Y_train = numpy.array(Y_train)
X_test = numpy.array(X_test)
Y_test = numpy.array(Y_test)

X_train = numpy.expand_dims(X_train, axis=-1)
Y_train = convert_to_one_hot(Y_train, 36)

X_test = numpy.expand_dims(X_test, axis=-1)
Y_test = convert_to_one_hot(Y_test, 36)

print("Shape of X_train: ", X_train.shape)
print("Shape of Y_train: ", Y_train.shape)
print("Shape of X_test: ", X_test.shape)
print("Shape of Y_test: ", Y_test.shape)

def final_model(input_shape=(128, 32, 1), classes=36):
    X_input = Input(input_shape)
    Z = Conv2D(32, (5, 5), strides=(1, 1), padding='same', name='conv1',
               kernel_initializer=glorot_uniform(seed=0), 
               kernel_regularizer=l2(0.00001))(X_input)
    Z = Activation(activation='relu')(Z)
    Z = MaxPooling2D((2, 2), strides=(2, 2))(Z)
    Z = Conv2D(64, (5, 5), strides=(1, 1), padding='same', name='conv2',
               kernel_initializer=glorot_uniform(seed=0), 
               kernel_regularizer=l2(0.00001))(Z)
    Z = Activation(activation='relu')(Z)
    Z = MaxPooling2D((2, 2), strides=(2, 2))(Z)
    Z = Conv2D(64, (3, 3), strides=(1, 1), padding='same', name='conv3',
               kernel_initializer=glorot_uniform(seed=0), 
               kernel_regularizer=l2(0.00001))(Z)
    Z = Activation(activation='relu')(Z)
    Z = MaxPooling2D((2, 2), strides=(2, 2))(Z)
    Z = Conv2D(128, (3, 3), strides=(1, 1), padding='same', name='conv4',
               kernel_initializer=glorot_uniform(seed=0), 
               kernel_regularizer=l2(0.00001))(Z)
    Z = Activation(activation='relu')(Z)
    Z = MaxPooling2D((2, 2), strides=(2, 2))(Z)
    Z = Conv2D(256, (3, 3), strides=(1, 1), padding='same', name='conv5',
               kernel_initializer=glorot_uniform(seed=0), 
               kernel_regularizer=l2(0.00001))(Z)
    Z = Activation(activation='relu')(Z)
    Z = MaxPooling2D((2, 2), strides=(2, 2))(Z)
    Z = Flatten()(Z)
    Z = Dense(120, activation='relu', name='fc1',
              kernel_initializer=glorot_uniform(seed=0), 
              kernel_regularizer=l2(0.00001))(Z)
    Z = Dense(84, activation='relu', name='fc2',
              kernel_initializer=glorot_uniform(seed=0), 
              kernel_regularizer=l2(0.00001))(Z)
    Z = Dense(classes, activation='softmax', name='fc3',
              kernel_initializer=glorot_uniform(seed=0))(Z)

    complete_model = Model(inputs=X_input, outputs=Z, name='final_model')
    return complete_model

aug = ImageDataGenerator(rotation_range=10, zoom_range=0.05, 
                         width_shift_range=0.1, height_shift_range=0.1, 
                         shear_range=0.15, horizontal_flip=False, 
                         fill_mode='nearest')
combine_model = final_model(input_shape=(128, 32, 1), classes=36)
combine_model.compile(optimizer='adam', loss='categorical_crossentropy', 
                      metrics=['accuracy'])
combine_model.summary()
combine_model.fit(aug.flow(X_train, Y_train, batch_size=1024), epochs=50, 
                  batch_size=1024)
predictions = combine_model.evaluate(X_test, Y_test)
print("Loss: ", predictions[0])
print("Accuracy: ", predictions[1])

